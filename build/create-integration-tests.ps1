$templateSources = @(
    [PSCustomObject]@{
        Repo = 'https://github.com/aws-samples/sessions-with-aws-sam.git'
        CloneDir = Join-Path ([IO.Path]::GetTempPath()) 'sessions-with-aws-sam'
        CopyFrom = '.'
    }
    [PSCustomObject]@{
        Repo = 'https://github.com/awslabs/aws-cloudformation-templates.git'
        CloneDir = Join-Path ([IO.Path]::GetTempPath()) 'aws-cloudformation-templates'
        CopyFrom = '.'
    }
)

$testDir = '../tests/Firefly.CloudFormationParser.Tests.Integration'
$partialResourceDir = 'Resources/FullTemplates'
$resourceDir = Join-Path (Join-Path $PSScriptRoot $testDir) $partialResourceDir
$git = Get-Command -Name git
$cfnFlip = Get-Command cfn-flip
$cfnLint = Get-Command cfn-lint

$projectSkeleton = @"
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netcoreapp3.1</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Firefly.CloudFormationParser.Tests.Common\Firefly.CloudFormationParser.Tests.Common.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Remove="Resources\Snippets\base64-tests.yaml" />
    <None Remove="Resources\Snippets\condition-section-tests.yaml" />
    <None Remove="Resources\Snippets\getazs-tests.yaml" />
    <None Remove="Resources\Snippets\nested-tag.json" />
    <None Remove="Resources\Snippets\nested-tag.yaml" />
    <None Remove="Resources\Snippets\policy-condition-post.yaml" />
    <None Remove="Resources\Snippets\policy-condition-pre.yaml" />
    <None Remove="Resources\Snippets\quoted-keys.yaml" />
    <None Remove="Resources\Snippets\template1.json" />
    <None Remove="Resources\Snippets\template1.yaml" />
    <None Remove="Resources\Snippets\sam-dependencies.yaml" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Resources\Snippets\base64-tests.yaml" />
    <EmbeddedResource Include="Resources\Snippets\condition-section-tests.yaml" />
    <EmbeddedResource Include="Resources\Snippets\getazs-tests.yaml" />
    <EmbeddedResource Include="Resources\Snippets\nested-tag.json" />
    <EmbeddedResource Include="Resources\Snippets\nested-tag.yaml" />
    <EmbeddedResource Include="Resources\Snippets\policy-condition-post.yaml" />
    <EmbeddedResource Include="Resources\Snippets\policy-condition-pre.yaml" />
    <EmbeddedResource Include="Resources\Snippets\quoted-keys.yaml" />
    <EmbeddedResource Include="Resources\Snippets\template1.json" />
    <EmbeddedResource Include="Resources\Snippets\template1.yaml" />
    <EmbeddedResource Include="Resources\Snippets\sam-dependencies.yaml" />
  </ItemGroup>
</Project>
"@

$testSkeleton = @"
/*
** Generated by build/create-integration-tests.ps1
** Any direct changes to this file may be overwritten.
*/
namespace Firefly.CloudFormationParser.Tests.Integration
{
    using System;
    using System.IO;

    using Firefly.CloudFormationParser.Intrinsics.Functions;
    using Firefly.CloudFormationParser.Serialization.Settings;
    using Firefly.CloudFormationParser.TemplateObjects;
    using Firefly.CloudFormationParser.Tests.Common;

    using FluentAssertions;

    using Xunit;

    using YamlDotNet.Core;

    /// <summary>
    /// This test suite takes a bunch of templates from https://github.com/awslabs/aws-cloudformation-templates,
    /// deserializes them and records a DOT graph, re-serializes the output of the deserialization, then
    /// deserializes again and records another DOT graph.
    /// If the two DOT graphs are the same, then the deserialize-serialize process is deemed successful.
    /// </summary>
    /// <seealso cref="Firefly.EmbeddedResourceLoader.AutoResourceLoader" />
    public class FullTemplatesIntegrationTest : IClassFixture<FullTemplatesIntegrationTestFixture>
    {
        private readonly FullTemplatesIntegrationTestFixture fixture;

        public FullTemplatesIntegrationTest(FullTemplatesIntegrationTestFixture fixture)
        {
            this.fixture = fixture;
        }

        [SkippableTheory]
/*THEORIES_WITH_CONDITIONAL*/
        public async void DeserializeThenReserializeShouldProduceSameGraph(
            string templateFile,
            string format,
            bool excludeConditionalResources)
        {
            // If a template is deserialized, re-serialized then deserialized again
            // the dependency graph for each deserialization should match.
            var template = await Template.Deserialize(
                new FileDeserializerSettings(
                    Path.Combine(this.fixture.TempDirectory, $"{templateFile}.{format}"))
                    {
                        ExcludeConditionalResources = excludeConditionalResources
                    });

            var initialDotGraph = TestHelpers.GenerateDotGraph(template);
            var yaml = Template.Serialize(template);

            ITemplate finalTemplate;

            try
            {
                finalTemplate = await Template.Deserialize(new StringDeserializerSettings(yaml));
            }
            catch (YamlException e)
            {
                Skip.If(e.InnerException is ArgumentNullException { Message: "Value cannot be null. (Parameter 'key')" }, "Bug in YamlDotNet where a key name of 'null' is not quoted on serialization. https://github.com/aaubry/YamlDotNet/issues/591.");

                throw;
            }

            var finalDotGraph = TestHelpers.GenerateDotGraph(finalTemplate);

            initialDotGraph.Should().Be(finalDotGraph);
        }

        [Theory]
/*THEORIES_WITHOUT_CONDITIONAL*/
        public async void ShouldNotDeserializeConditionWithinResourcePropertiesAsIntrinsic(
            string templateFile,
            string format)
        {
            // Test for an issue when deserializing resources, in that a key of "Condition" within the resource
            // properties is incorrectly converted to a Condition intrinsic
            var template = await Template.Deserialize(new FileDeserializerSettings(
                Path.Combine(this.fixture.TempDirectory, $"{templateFile}.{format}")));

            // Assert that conditions on policy statements were not deserialized as intrinsic
            foreach (var resource in template.Resources)
            {
                TestHelpers.ContainsObjectOfType(resource.Properties, typeof(ConditionIntrinsic)).Should()
                    .BeFalse(
                        "'Condition' within resource properties (e.g. policies) should not be deserialized as intrinsic");
            }
        }

        [Theory]
/*THEORIES_WITHOUT_CONDITIONAL*/
        public async void ShouldSerializeComplexObjectsWhichAreArgumentsOfInstrinsics(
            string templateFile,
            string format)
        {
            // Test that complex structures that are arguments of an intrinsic, e.g. an entire policy document
            // as one of the branches of !If are correctly serialized.
            // When they aren't, then we see type names like System.Collections.Generic.Dictionary since the dict
            // was serialized as a scalar and ToString was implicitly called.
            var template = await Template.Deserialize(new FileDeserializerSettings(
                            Path.Combine(this.fixture.TempDirectory, $"{templateFile}.{format}")));

            var yaml = Template.Serialize(template);

            // Assert compound structures within intrinsics were correctly serialized.
            yaml.Should().NotContain("System.Collections.", "type should have been serialized");
        }
    }
}
"@

try
{
    if (-not (Test-Path -Path $resourceDir -PathType Container))
    {
        New-Item $resourceDir -ItemType Directory | Out-Null
    }

    Remove-Item -Path "$resourceDir/*.yaml" -Force
    Remove-Item -Path "$resourceDir/*.json" -Force

    $rejectedByLinter = 0

    $templateSources |
    ForEach-Object {
        & $git clone --depth 1 $_.Repo $_.CloneDir

        Write-Host -NoNewLine "Validating and copying"
        Get-ChildItem -Path (Join-Path $_.CloneDir $_.CopyFrom) -Filter *.yaml -Recurse |
        Where-Object {
            Write-Host -NoNewline '.'

            # Elimante files with linter errors
            $errs = & $cfnLint $_.FullName | Select-String '^E\d+' | Select-Object -ExpandProperty Line

            $ok = [string]::IsNullOrEmpty($errs)

            if (-not $ok)
            {
                ++$rejectedByLinter
            }

            $ok
        } |
        Foreach-Object {
            $newName = $_.BaseName.Replace('.', '_')

            if ($_.BaseName -eq 'template')
            {
                $newName = "$($_.Directory.Name)_$newName"
            }

            Copy-Item $_.FullName (Join-Path $resourceDir $_.Name.Replace($_.BaseName, $newName))
        }

        Write-Host
        Write-Host "Rejected: $rejectedByLinter"
        Remove-Item -Path $_.CloneDir -Recurse -Force
    }

    $xname = [System.Xml.Linq.XName]'ItemGroup'
    $removeElement = [System.Xml.Linq.XElement]::new($xname)
    $embeddedResourcesElement = [System.Xml.Linq.XElement]::new($xname)

    Push-Location $resourceDir
    $sbWithConditional = [System.Text.StringBuilder]::new()
    $sbWithoutConditional = [System.Text.StringBuilder]::new()
    $yamlFiles = Get-ChildItem -Filter *.yaml

    Write-Host -NoNewLine "Creating JSON templates"

    $yamlFiles |
    ForEach-Object {
        & $cfnFlip "$($_.BaseName).yaml" "$($_.BaseName).json"
        Write-Host -NoNewline '.'
    }

    Write-Host
    Write-Host "Generating YAML tests..."

    $yamlFiles |
    Foreach-Object {
        $path = "$partialResourceDir\$($_.Name)".Replace('/', '\')
        $removeElement.Add(
            [System.Xml.Linq.XElement]::new('None',
                [System.Xml.Linq.XAttribute]::new('Remove', $path)
            )
        )
        $embeddedResourcesElement.Add(
            [System.Xml.Linq.XElement]::new('EmbeddedResource',
                [System.Xml.Linq.XAttribute]::new('Include', $path)
            )
        )

        $sbWithConditional.AppendLine("        [InlineData(`"$($_.BaseName)`", `"yaml`", true)]") | Out-Null
        $sbWithConditional.AppendLine("        [InlineData(`"$($_.BaseName)`", `"yaml`", false)]") | Out-Null
        $sbWithoutConditional.AppendLine("        [InlineData(`"$($_.BaseName)`", `"yaml`")]") | Out-Null
    }

    Write-Host "Generating JSON tests..."

    Get-ChildItem -Filter *.json  |
    Foreach-Object {
        $path = "$partialResourceDir\$($_.Name)".Replace('/', '\')
        $removeElement.Add(
            [System.Xml.Linq.XElement]::new('None',
                [System.Xml.Linq.XAttribute]::new('Remove', $path)
            )
        )
        $embeddedResourcesElement.Add(
            [System.Xml.Linq.XElement]::new('EmbeddedResource',
                [System.Xml.Linq.XAttribute]::new('Include', $path)
            )
        )

        $sbWithConditional.AppendLine("        [InlineData(`"$($_.BaseName)`", `"json`", true)]") | Out-Null
        $sbWithConditional.AppendLine("        [InlineData(`"$($_.BaseName)`", `"json`", false)]") | Out-Null
        $sbWithoutConditional.AppendLine("        [InlineData(`"$($_.BaseName)`", `"json`")]") | Out-Null
    }

    Pop-Location

    $sr = [System.IO.StringReader]::new($projectSkeleton)
    $project = [System.Xml.Linq.XDocument]::Load($sr)
    $project.FirstNode.Add($removeElement)
    $project.FirstNode.Add($embeddedResourcesElement)
    $project.Save((Resolve-Path (Join-Path $testDir Firefly.CloudFormationParser.Tests.Integration.csproj)).Path)

    [IO.File]::WriteAllText((Resolve-Path (Join-Path $testDir FullTemplatesIntegrationTest.cs)).Path,
        $testSkeleton.Replace('/*THEORIES_WITH_CONDITIONAL*/', $sbWithConditional.ToString()).Replace('/*THEORIES_WITHOUT_CONDITIONAL*/', $sbWithoutConditional.ToString()),
        [System.Text.UTF8Encoding]::new($false))
}
finally
{
    if ($sr)
    {
        $sr.Dispose()
    }
}